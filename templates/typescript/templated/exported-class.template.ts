import { template } from "lodash";

export default template(`
// Code generated by @open-rpc/client-generator DO NOT EDIT.
import { RequestManager, WebSocketTransport, HTTPTransport, Client } from '@open-rpc/client-js';
import _ from "lodash";
import { OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator } from "@open-rpc/schema-utils-js";

<%= methodTypings.toString("typescript") %>

export interface Options {
  transport: {
    type: "websocket" | "http" | "https";
    host: string;
    port: number;
    path?: string;
  }
}

export class <%= className %> {
  public rpc: Client;
  private validator: MethodCallValidator;
  private openrpcDocument: OpenRPC;

  constructor(options: Options) {
    this.openrpcDocument = <%= JSON.stringify(openrpcDocument) %>;

    if (options.transport === undefined || options.transport.type === undefined) {
      throw new Error("Invalid constructor params");
    }
    const {type, host, port} = options.transport;
    let path = options.transport.path || "";
    if(path && path[0] !== "/") {
        path = "/" + path;
    }
    let transport;
    switch (type) {
      case 'http':
      case 'https':
        transport = new HTTPTransport(type + "://" + host + ":" + port + path)
        break;
      case 'websocket':
        transport = new WebSocketTransport("ws://" + host + ":" + port + path)
        break;
      default:
        throw new Error("unsupported transport");
        break;
    }
    this.rpc = new Client(new RequestManager([transport]));
    this.validator = new MethodCallValidator(this.openrpcDocument);
  }

  /**
   * Initiates [[<%= className %>.startBatch]] in order to build a batch call.
   *
   * Subsequent calls to [[<%= className %>.request]] will be added to the batch.
   * Once [[<%= className %>.stopBatch]] is called, the promises for the [[<%= className %>.request]]
   * will then be resolved.  If there is already a batch in progress this method is a noop.
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public startBatch(): void {
    return this.rpc.startBatch();
  }

  /**
   * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.
   *
   * stopBatch will send the [[<%= className %>]] calls made since the last [[<%= className %>.startBatch]] call. For
   * that reason, [[<%= className %>.startBatch]] MUST be called before [[<%= className %>.stopBatch]].
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public stopBatch(): void {
    return this.rpc.stopBatch();
  }

  private request(methodName: string, params: any[]): Promise<any> {
    const methodObject = _.find(this.openrpcDocument.methods, ({name}) => name === methodName) as MethodObject;
    const openRpcMethodValidationErrors = this.validator.validate(methodName, params);
    if (openRpcMethodValidationErrors.length > 0) {
      return Promise.reject(openRpcMethodValidationErrors);
    }

    let rpcParams;
    if (methodObject.paramStructure && methodObject.paramStructure === "by-name") {
      rpcParams = _.zipObject(params, _.map(methodObject.params, "name"));
    } else {
      rpcParams = params;
    }
    return this.rpc.request(methodName, rpcParams);
  }

  <% openrpcDocument.methods.forEach((method) => { %>
  /**
   * <%= method.summary %>
   */
  public <%= method.name %>: <%= methodTypings.getTypingNames("typescript", method).method %> = (...params) => {
    return this.request("<%= method.name %>", params);
  }
  <% }); %>
}
export default <%= className %>;
`);
